#import "@preview/lovelace:0.2.0": *
// 使用伪粗体修复中文粗体不能正确显示的问题
#import "@preview/cuti:0.3.0": show-cn-fakebold

#import "fonts/font-def.typ": *
#import "pages/acknowledgement.typ": acknowledgement
#import "pages/chinese-outline.typ": chinese_outline
#import "pages/declaration.typ": declaration
#import "pages/zh-abstract-page.typ": zh_abstract_page
#import "pages/en-abstract-page.typ": en_abstract_page
#import "pages/references.typ": _set_references
#import "pages/paper-cover.typ": paper_cover
#import "pages/paper-pages.typ": *

#import "utilities/three-line-table.typ": three_line_table
#import "utilities/indent-funs.typ": *
#import "utilities/bib-cite.typ": *
#import "utilities/set-heading.typ": _set_heading
#import "utilities/set-figure.typ": _set_figure
#import "utilities/set-numbering.typ": _set_numbering

#import "variable/mse-proposal-variable.typ": *

#let project(
  anonymous: false, // 是否匿名化处理
  title: "",
  school: "",
  author: "",
  id: "",
  mentor: "",
  class: "",
  date: (2025, 2, 12),
  body,
) = {
  /* 全局整体设置 */

  // 设置标题, 需要在图表前设置
  show: _mse_proposal_set_heading
  // 图表公式的排版
  show: _set_figure
  // 图表公式的序号
  show: _set_numbering
  // 参考文献
  show: _mse_proposal_set_references.with(csl_style: "../pages/hust-cse-ug.csl")
  // 修复缩进
  show: _fix_indent
  // 整体页面设置
  show: _set_paper_page_size
  // 修复中文粗体不能正确显示的问题
  show: show-cn-fakebold

  /* 封面与原创性声明 */

  // 封面
  mse_proposal_paper_cover(cover_logo_path: "../assets/cs-hust.png", 
    anonymous, title, school, class, author, id, mentor, date
  )

  // 开题报告填写要求
  mse_proposal_declaration()

  // 正文
  pagebreak()
  counter(page).update(1)

  /* 正文 */

  // 整体页眉
  show: _mse_proposal_set_paper_page_header.with(anonymous: anonymous)
  // 整体段落与页面设置
  show: _set_paper_page_par

  // 正文的页脚
  show: _mse_proposal_set_paper_page_footer_main

  counter(page).update(1)

  body

  pagebreak()

  mse_proposal_inspect()

}

#show: project.with(
  anonymous: false,
  title: "基于LLM辅助的内核驱动数据竞争漏洞挖掘",
  id: "U202112205",
  author: "刘浩阳",
  school: "网络空间安全学院",
  class: "网安本硕博2101班",
  mentor: "慕冬亮",
  date: (2025, 2, 12),
)

= 课题来源、目的及意义

== 课题来源
本课题来源于香港科技大学Dongdong SHE教授的研究课题。本课题旨在使用LLM的代码和推理能力解决传统工具速度慢，精确度低等缺点。

== 课题目的
本课题的研究目标是深入了解传统静态分析和动态分析等技术，分析这些工具在效率、准确度等方面的缺陷，同时结合LLM的代码和推理能力，在已有工具上进行改进，设计一种高效，准确，适配性强且高度自动化的内核驱动数据竞争漏洞挖掘工具。

== 课题意义
随着操作系统内核的复杂性不断增加，并发编程模型在内核中的广泛应用，也导致了内核并发漏洞成为系统安全领域的一个重要问题。而数据竞争（Data Race）作为其中较为严重的问题。Linux内核作为全球广泛应用的开源操作系统，其驱动程序通常承载着与硬件直接交互的核心功能，因此其安全性至关重要。然而，传统的静态分析和动态检测方法在内核驱动数据竞争漏洞的发现上存在准确性和效率上的不足，尤其是在面对复杂的并发场景时。大规模语言模型（LLM）由于其强大的语义理解和模式识别能力，能够辅助分析复杂代码逻辑并识别潜在的漏洞。结合LLM的自然语言处理能力与现有的分析工具，可以极大提升内核驱动中数据竞争漏洞的检测精度，降误报率，从而提高系统的安全性。

本研究的意义在于，首先通过大规模语言模型对内核驱动程序中的数据竞争模式进行挖掘，能够发现传统方法难以捕捉的潜在漏洞。其次，基于LLM的辅助检测方法能够有效弥补传统静态分析技术在处理内核复杂性时的不足，并通过结合符号执行和模糊测试等动态分析手段，提升对漏洞的检测能力。最终，本研究不仅有助于提升Linux内核驱动的安全性，也为操作系统内核的漏洞检测提供了一种新的思路和技术框架，对于未来的操作系统安全研究具有重要的推动作用。

= 国内外研究现况及发展趋势
与本课题有关的研究重点主要在三个方面，一是针对内核的数据竞争漏洞挖掘，二是针对内核驱动的安全研究和漏洞挖掘，三是大规模语言模型在软件安全领域的应用。下面将从这三个方面阐述国内外相关领域的研究现状和发展趋势。

== 内核数据竞争漏洞挖掘
传统的内核数据漏洞检测方法多依赖于静态分析和动态分析两大技术。静态分析通过解析源代码或二进制代码#bib_cite(<Razzer>, <LR-Miner>, <RacerX>, <Dr.Checker>, <OFence>, <WHOOP>, <DCUAF>, <DLOS>, <IMMI>)，识别潜在的并发问题，主要技术有静态锁集分析#bib_cite(<LR-Miner>, <RacerX>, <DCUAF>, <DLOS>)，指针分析#bib_cite(<Razzer>, <Dr.Checker>)，污点分析#bib_cite(<Dr.Checker>), 符号执行#bib_cite(<WHOOP>)等。但在面对复杂的多线程交互和数据共享场景时，静态分析的精度和覆盖率往往有限。而动态分析通过运行时监控和跟踪程序行为#bib_cite(<LockDoc>, <PLA>, <SEGFUZZ>, <HBFourier>, <Syzkaller>, <Snowcat>, <Snowboard>, <StateFuzz>)，能够收集运行时信息并且捕捉并发漏洞的执行过程，但其对系统运行状态的依赖使得检测可能不具备普适性，且容易受到测试用例覆盖率的限制。

== 内核驱动安全研究
内核具有极为庞大的代码量，而内核驱动作为特权代码的薄弱环节，其漏洞挖掘面临接口复杂、模型多样的挑战。这些驱动程序通常承载着与硬件直接交互的核心功能，因此其安全性至关重要。内核驱动程序的安全研究主要集中于通过静态分析等技术手段发掘漏洞上，如Drifuzz#bib_cite(<DriFuzz>)，通过构建设备状态机模型，有效生成触发深度漏洞的IOCTL序列。来自帝国理工学院和犹他大学的研究者提出了WHOOP#bib_cite(<WHOOP>)，该方法使用符号化锁集分析和建模的方法，对Linux 4.0中的16个驱动进行分析。值得关注的是，现有研究多集中于通用驱动模块（如USB、网络驱动），但缺少对专用硬件驱动（如工业控制、物联网设备）的建模。

== 大规模语言模型在软件安全领域的应用
大规模语言模型在漏洞挖掘领域正引发范式革新。已经有很多研究者试图将大预言模型应用到软件安全和系统安全领域#bib_cite(<Llift>, <IRIS>, <misc>, <GPTScan>)。来自宾夕法尼亚大学的研究者在传统的污点分析基础上，使用大语言模型进行污点标注和复杂推理等工作#bib_cite(<IRIS>)，同时他们还提出了一个新的漏洞数据集CWE-Bench-Java#bib_cite(<CWE-Bench-Java>)，用于评估大语言模型的漏洞检测能力，实验结果表明，在大语言模型的加持下，漏洞检测的成功率最高提高了23.33%，误报率最高下降了5.21%。来自加州大学河滨分校的研究者将大语言模型与符号执行相结合#bib_cite(<Llift>)，使用大语言模型识别和推理复杂的执行路径，并预测更有可能被执行的代码段，其结果在召回率和准确率上相较于原有的符号执行工具都有不小的提高。但尚未有研究者将大语言模型应用到操作系统等大型项目上，也没有相关工作探索大语言模型在内核漏洞挖掘领域的应用。

通过上述的研究现状总结可以看出，当前学术界对于Linux驱动中的数据竞争研究存在以下问题：
+ *传统检测方法的适应性局限*： 传统的静态分析和动态分析方法在内核驱动数据竞争漏洞的检测上存在准确性和效率上的不足，尤其是在面对复杂的并发场景时。
+ *驱动安全研究覆盖率不足*：现有的内核驱动漏洞挖掘工具多集中于通用驱动模块，不具有普适性，对专用硬件驱动的覆盖率不足。
+ *缺乏LLM在系统安全领域的探索*：大规模语言模型在软件安全领域的应用尚未涉及到操作系统等大型项目，缺少相关工作。

= 预计达到的目标、关键理论和技术、主要研究内容、完成课题的方案及主要措施

== 预期目标
本课题针对上面提出的问题，深入了解传统静态分析和动态分析技术，分析这些工具在效率、准确度等方面的缺陷，同时结合LLM的代码和推理能力，在已有工具上进行改进，设计一种高效，准确，适配性强且高度自动化的内核驱动数据竞争漏洞挖掘工具。具体而言，本课题的研究目标分为以下几个部分：
+ 学习并了解传统的静态分析和动态分析技术的原理，分析这些工具在效率、准确度等方面的缺陷及其原因。
+ 在原有技术的基础上，设计一套高效，准确，适配性强且高度自动化的内核驱动数据竞争漏洞挖掘工具。
+ 结合LLM的代码和推理能力，辅助分析复杂代码逻辑，提高检测的准确性，降低误报率，提高检测精度和效率等。
+ 针对最新的Linux内核源码进行分析，挖掘当前版本中的数据竞争漏洞。


== 关键理论和技术
=== 指针分析
指针分析（Pointer Analysis）是程序分析中的一种技术，旨在追踪程序中的指针变量，推测指针可能指向的内存位置或对象。它是静态分析中的一个重要领域，广泛应用于程序优化、错误检测、安全分析、内存管理等多个方面。通过对指针的分析，能够推测出指针间的关系、指针与内存之间的映射关系、指针可能指向的对象等信息。
指针分析通常可以分为如下几种类型：

- *上下文敏感指针分析（Context-Sensitive Pointer Analysis）*： 上下文敏感指针分析考虑程序调用的上下文（如函数调用栈），因此能够对不同的调用上下文做出不同的分析结果。相较于上下文无关分析，它能够提供更精确的信息，但计算成本较高。
- *流敏感指针分析（Flow-Sensitive Pointer Analysis）*： 流敏感指针分析考虑程序的控制流路径，即在不同的程序执行路径上，指针可能指向不同的对象。这种分析可以捕捉到更多的程序行为，但也需要较高的计算资源。

#indent()Andersen算法#bib_cite(<Andersen>)是一种常用的指针分析算法，用于静态分析程序中的指针变量，以推断指针可能指向的内存位置。它属于上下文不敏感的指针分析方法，其核心思想是通过对程序中指针的赋值和操作进行分析，推断出哪些指针可能指向相同的内存位置。它通过建立指针与内存位置之间的“点-对”关系（Point-to Set）来进行分析。在这个算法中，每个指针变量都与一个集合相关联，集合中的元素表示该指针可能指向的内存位置。

指针分析通常可以帮助追踪内存的分配和释放，检测内存泄漏、非法内存访问等问题，在并发程序中，指针分析有助于发现数据竞争和其他并发问题，尤其是在多线程环境下的共享资源访问。

=== 内核模糊测试
内核模糊测试（Kernel Fuzzing）是一种针对操作系统内核及其模块的漏洞检测技术，利用自动化工具向内核输入大量随机或变异的输入数据，目的是发现潜在的安全漏洞、内存错误和异常行为。这种方法可以帮助发现一些难以通过传统代码审查或静态分析捕获的漏洞，特别是一些与内核代码的复杂交互有关的问题。当前来说，对于内核的模糊测试还使用了覆盖率引导，混合符号执行等技术，以提高模糊测试的效率和覆盖率，其中的较为有名的工具有Syzkaller#bib_cite(<Syzkaller>)、AFL#bib_cite(<AFL>)、AFL++#bib_cite(<AFLPP>)等。

内核模糊测试技术的主要优势在于其高度自动化，能够在短时间内发现大量的潜在漏洞，同时也能够帮助开发者验证内核的稳定性和安全性。但是，内核Fuzzing也存在一些挑战，如内核的复杂性、模糊测试的效率和覆盖率等问题。因此，如何提高内核模糊测试的效率和覆盖率，是当前内核安全研究的一个重要方向。

=== LLVM Bitcode
LLVM Bitcode是LLVM编译器#bib_cite(<llvm>)生成的一种中间表示（IR），它是一种低级的、与机器无关的表示形式，可以用于优化、分析和转换程序。LLVM Bitcode具有很强的可移植性和可扩展性，可以在不同的平台上进行编译和执行。LLVM Bitcode通常以.bc文件的形式存储，可以通过LLVM工具链进行编译、优化和执行。

LLVM Bitcode 在程序分析中非常有用，因为它提供了一个独特的方式让研究者和开发者对程序进行分析和修改。研究者通过LLVM Bitcode可以实现对程序的静态分析、动态分析、符号执行、模糊测试等操作，从而发现程序中的潜在问题和漏洞。在内核数据竞争漏洞挖掘中，LLVM Bitcode可以帮助研究者对内核代码进行分析和修改，提高漏洞检测的准确性和效率。

=== 提示词工程
提示词工程（Prompt Engineering）是一种通过设计和优化“提示语”（prompts）来引导大语言模型（如 GPT 系列、BERT 等）产生预期输出的技术。随着大语言模型的广泛应用，提示词工程变得越来越重要，因为模型的性能和输出质量在很大程度上取决于输入的提示语。

提示词工程的目标是设计一组有效的提示语，以引导模型产生特定的输出。这些提示语可以是单词、短语、句子甚至段落，通常包含问题描述、关键信息、约束条件等内容。通过合理设计提示语，可以提高模型的性能、准确性和可解释性。提示词工程在问答系统、文本生成、对话系统等领域有着广泛的应用。

研究人员可利用提示工程来提升大语言模型处理复杂任务场景的能力，如问答和算术推理能力。开发人员可通过提示工程设计、研发强大的工程技术，实现和大语言模型或其他生态工具的高效接轨。

== 主要研究内容
本课题主要研究如何有效的将静态分析与动态分析相结合，同时探索如何高效利用大语言模型的代码和推理能力，设计一种高效，准确，适配性强且高度自动化的内核驱动数据竞争漏洞挖掘工具。具体而言，本课题的主要研究内容包括：
+ 将静态分析和动态分析相结合，具体来说，先进行静态分析得到初步结果，然后使用动态分析对其进行进一步挖掘和验证，提高检测的准确性，同时设计一套具有普适性，可以适用于所有驱动的分析方法。
+ 使用大语言模型的推理和代码理解能力，辅助分析复杂代码逻辑，比如生成系统调用序列，降低误报率，提高检测精度和效率等。

== 课题方案及主要措施
=== 基于LLVM IR的指针分析
静态分析的主要内容就是指针分析，而对于Linux内核这样庞大的项目，指针分析的效率和准确性是非常重要的。

==== 生成LLVM IR
首先需要将Linux内核源码从C语言转换为LLVM IR，这样才能进行后续的分析。而在这个过程中，考虑到Linux对Clang编译器的支持还不够完善，我们选择了WLLVM工具生成LLVM IR。首先使用WLLVM对内核源码进行编译获得归档文件，然后使用WLLVM提供的工具从归档文件中提取LLVM IR。

==== 生成MSSA
MSSA（Memory Static Single Assignment）是内存指令的静态单赋值形式表示，它将内存操作转换为SSA形式，方便后续的分析。我们使用SVF（Static Value-Flow Analysis Framework）工具#bib_cite(<SVF>)来分析LLVM IR，进而生成MSSA。SVF是一个开源的静态分析框架，其提供了一套完整的指针分析工具，并且实现了不同版本的指针分析算法，如Andersen算法、Steensgaard算法等，在这里我们使用上下文敏感和流敏感的改进版Andersen算法。

由于LLVM IR有多种指令，而我们主要关注内存操作，因此需要对LLVM IR进行预处理，在生成MSSA时只保留内存操作相关的指令。这里选择性保留了三种指令，其功能如 @tbl:tbl:inst 所示。

#set table(
  stroke: none,
  gutter: 0.2em,
  fill: (x, y) =>
    if x == 0 or y == 0 { gray },
  inset: (right: 1.5em),
)

#figure(
  table(
    columns: (100pt, 100pt, 200pt),
    inset: 10pt,
    align: horizon,
    [指令],[功能],[示例],
    [LoadInst], [加载一个内存], table.cell(fill: green.lighten(60%))[load i32, i32\* %ptr],
    [StoreInst], [写入一个内存], table.cell(fill: green.lighten(60%))[store i32 1, i32\* %ptr],
    [CallInst], [调用一个函数], table.cell(fill: green.lighten(60%))[call void \@foo(i32 1)],
  ),
  caption: [LLVM IR内存操作指令],
)<tbl:inst>

==== 生成内存对
通过分析这三种指令的内存访问情况，同时结合LLVM IR中的Debug信息，我们可以将可疑的内存访问指令对映射到源码中，从而产生静态分析的初步结果，即大量的内存访问对。

==== 生成syscall序列
在得到内存访问对后，为了验证和触发数据竞争，我们还需要生成系统调用序列，这样才能将得到的内存访问对转化为动态分析可以接受的输入，在这一部分我们计划通过生成驱动模块的控制流图（CFG），然后将得到的C语言变量映射到对应的CFG节点中，最终通过遍历CFG生成系统调用序列。

=== 内核模糊测试
在动态分析部分，计划采用Syzkaller+QEMU的方法进行模糊测试。由于Syzkaller对内核多线程Fuzzing的支持不够完善，我们计划将其进行改进，以适应我们在静态分析中发现的内存访问对。计划对Syzkaller添加如下特性以适配我们的实验：
+ 可以接受外部输入的syscall序列并执行，而不是随机生成。
+ 内核线程调度器及内核线程执行控制器，做到可以控制指令级别的执行顺序。
+ 自动挂载驱动模块，以测试不同的驱动模块，而不仅仅是内核本身。

#indent()下面将简单介绍这三个特性以及实现的思路。

==== 外部输入的syscall序列
在Syzkaller的设计中，它会随机生成syscall序列，然后通过QEMU执行，这样的方法对于我们的实验是不够的，因为我们需要将静态分析得到的内存访问对转化为系统调用序列，因此我们需要对Syzkaller进行改进，使其可以接受外部输入的syscall序列。而要想实现这个效果，需要对Syzkaller的源码进行修改，具体的模块为syz-executor和syz-fuzzer，其中syz-executor负责执行syscall，而syz-fuzzer负责生成syscall序列。通过修改这两个模块的源码，我们可以将外部输入的syscall序列传递给syz-executor，然后执行。

==== 内核线程调度器
由于数据竞争漏洞常常是由指令级别的并发访问引起的，因此在验证其存在性时，我们需要做到控制指令级别的执行顺序，在过去的工作中，常见的做法是在关键指令前添加随机的时延来做到指令调度，但这种方法不够精确，因此我们计划在Syzkaller中添加一个内核线程调度器，通过控制内核线程的执行顺序来实现指令级别的调度。具体的实现思路是在syz-executor中添加一个线程调度器模块，通过动态添加程序断点来控制线程的执行，进而控制多线程的指令执行顺序。

==== 自动挂载驱动模块
在实际的内核数据竞争漏洞挖掘中，我们不仅仅需要测试内核本身，还需要测试内核的驱动模块，因此我们需要对QEMU进行改进，使其可以自动挂载驱动模块。具体的实现思路是在QEMU中修改驱动模块加载的逻辑，或者在QEMU中增加一个模块，使其可以自动加载指定的驱动模块。

=== 大语言模型的应用
关于大语言模型在本课题中的应用，我们计划使用其来进行如下工作：
+ *降低误报率*：通过大语言模型的代码理解能力，辅助分析复杂代码逻辑，提高检测的准确性，降低误报率。
+ *提高效率*：通过大语言模型的推理能力，生成系统调用序列，提高检测精度和效率。
#indent()下面将简单介绍这两个应用的实现思路。

==== 降低误报率
尽管使用了上下文敏感和流敏感的指针分析方法，但实际中静态分析的误报率仍然较高，因此我们计划使用大语言模型来降低误报率。具体的实现思路是，将静态分析得到的内存访问对转化为自然语言描述，然后通过大语言模型进行分析，找出其中误报并过滤掉，从而减少动态分析的压力。

==== 提高效率
由于大语言模型对代码的理解能力和推理能力较强，我们计划使用大语言模型来生成系统调用序列，以提高检测精度和效率。具体的实现思路是，将静态分析得到的CFG节点转化为自然语言描述，并且提供一些上下文信息，让大语言模型判断可能触发该函数的系统调用并且生成系统调用序列，从而提高检测的效率。同时，我们还会在动态执行过程中收集大量的执行信息，将其反馈给大语言模型，让其预测更有可能被执行的代码段，从而提高检测的效率。

#pagebreak()
= 课题研究进度安排

#[
#set par(leading: 0.75em)
#show figure: set block(breakable: true)
#figure(
  table(
    columns: (100pt, 100pt, 200pt),
    align: horizon,
    stroke: (x: none),
    //content
    table.header[学期][周次][工作任务],
    //
    table.cell(rowspan: 1,align:horizon, [2024-2025学年度第一学期]), 
    [14周——17周], [确认毕设选题并查阅相关文献资料，调研内核数据竞争的最新研究进展和发展趋势，学习指针分析等技术。],
    table.cell(rowspan: 1, [2024-2025学年寒假]),
    [——],[复现相关检测数据竞争的论文，确定初步技术路线。],
    //
    table.cell(rowspan: 5, [2024-2025学年度第二学期]), 
    [1周], [完善课题思路，撰写开题报告并完成外文翻译，完成开题答辩。],
    [2周——5周], [完成静态分析部分，得到初步的内存访问对。],
    [6周——12周], [完成动态分析和大语言模型部分，得到系统的雏形。],
    [13周——14周], [将检测系统应用到最新的几个Linux内核版本中，进行实验验证，申报得到的漏洞并确认。],
    [15周——17周], [撰写毕业论文，准备答辩。],
  ), caption: [课题研究进度安排表], kind: table
) <arrange>
]

#bibliography("ref.bib")